#!/usr/bin/env ruby -w

# Originally by Mike Clark.
#
# From http://www.pragmaticautomation.com/cgi-bin/pragauto.cgi/Monitor/StakingOutFileChanges.rdoc
#
# Runs a user-defined command when files are modified.
#
# Like autotest, but more customizable. This is useful when you want to do
# something other than run tests. For example, generate a PDF book, run
# a single test, or run a legacy Test::Unit suite in an app that also
# has an rSpec suite.
#
# Can use Ruby's Dir[] to get file glob. Quote your args to take advantage of this.
#
#  rstakeout 'rake test:recent' **/*.rb
#  => Only watches Ruby files one directory down (no quotes)
#
#  rstakeout 'rake test:recent' '**/*.rb'
#  => Watches all Ruby files in all directories and subdirectories
#
# Modified (with permission) by Geoffrey Grosenbach to call growlnotify for
# rspec and Test::Unit output.
#
# See the PeepCode screencast on rSpec or other blog articles for instructions on
# setting up growlnotify.
#
# * Added Snarl support in win32, initial implementation by Francis Fish
# * Added synchronous mode
# * Allow adjusting of sleep time
# * Fixes to work in Linux env too
# Edvard Majakari <edvard@majakari.net>
#
# Mod'd by @twerth:
#   Added ability to send file name to command, use -f, here is an example:
#     rstakeout 'javascriptlint' '**/*.js' -f
#
#   Added ability to suppress output, use -q, here is an example:
#     rstakeout 'javascriptlint' '**/*.js' -f -q
#
# Mod'd by @n0gg1n:
#   Altered code to check for (and process) new/created files
#   Added code to growl notify regardless of the status of an operation 
#   Added ability to provide an alternative command which runs when create/delete occurs on fs
#

require 'optparse'
require 'ostruct'
require 'rubygems'
require File.dirname(__FILE__) + '/../pshell'

def require_gem(gemname)
  begin
    require gemname
  rescue LoadError
    puts "Please install gem %s" % gemname
    exit 1
  end
end

FAIL_ICON_PATH = File.join(File.dirname(__FILE__), 'rails_fail.png')
OK_ICON_PATH = File.join(File.dirname(__FILE__), 'rails_fail.png')

case PLATFORM
when /darwin/
  require_gem 'ruby-growl'
when /win32/
  require_gem 'autosnarl'
else
  warn "Uh-oh, sorry. No Fancy-schmancy notifiers for #{PLATFORM}"
end

require_gem 'rake'

module GrowlNotifier
  class << self
    def notify(title, msg)
      system "growlnotify -p 10 -m '#{msg}' '#{title}'"
    end
    
    # private :notify

    def notify_fail(output)
      notify "Test/Spec FAIL", "#{output}", FAIL_ICON_PATH, 2
    end

    def notify_pass(output)
      notify "Test/Spec pass", "#{output}", OK_ICON_PATH
    end
  end
end

# TODO: instead of begin/rescue, do
# module SnarlNotifier < end
# module SnarlNotifier::AutoSnarl < end
# ?
begin
  module SnarlNotifier
    # Idea by Francis Fish, http://francis.blog-city.com/
    begin
      require 'autotest'
    rescue Exception
      nil
    end
    include AutoSnarl
    module ::AutoSnarl
      def self.snarl(title, msg, ico=nil, timeout=5)
        Snarl.show_message(title, msg, icon[ico], timeout)
      end
    end

    def self.notify_fail(output)
      AutoSnarl::snarl "FAIL", "#{output}", :red, 30
    end

    def self.notify_pass(output)
      AutoSnarl::snarl "Pass", "#{output}", :green, 10
    end
  end
rescue Exception
  nil
end

module EmptyNotifier
  def self.notify_pass(output)
  end
  def self.notify_fail(output)
  end
end

Notifier = case PLATFORM
  when /linux/: EmptyNotifier
  when /win32/: SnarlNotifier
  else
    GrowlNotifier
  end

module ParseSpecResult
 def self.notify_test_unit_results(results)
    output = results.slice(/(\d+)\s+tests?,\s*(\d+)\s+assertions?,\s*(\d+)\s+failures?(,\s*(\d+)\s+errors)?/)
    if output
      $~[3].to_i + $~[5].to_i > 0 ? Notifier.notify_fail(output) : Notifier.notify_pass(output)
      return true
    end
    return false
  end

  def self.notify_rspec_results(results)
    output = results.slice(/(\d+)\s+examples?,\s*(\d+)\s+failures?(,\s*(\d+)\s+not implemented)?/)
    if output
      $~[2].to_i > 0 ? Notifier.notify_fail(output) : Notifier.notify_pass(output)
      return true
    end
    return false
  end
end

def build_mtimes_hash(globs)
  files = {}
  FileList.send(:[], *globs).each { |file| files[file] = File.mtime(file) }
  files
end

trap('INT') do
  puts "\nQuitting..."
  exit
end

options = OpenStruct.new(:sleep_time => 1, :reload_glob => false, :synchronous => false)

OptionParser.new do |opts|
  opts.banner = "Usage: rstakeout.rb [options] <command> <filespec>+"
  opts.on("-t", "--sleep-time T", Integer, "time to sleep after each loop iteration") do |t|
    options.sleep_time = t
  end
  opts.on("-v", "--verbose") do |v|
    options.verbose = v
  end
  opts.on("--sync", "force synchronous mode (disallow simultaneous runs)") do |s|
    options.synchronous = s
  end
  opts.on("-f", "--include-file") do |v|
    options.include_file = v
  end
  opts.on("-q", "--quiet") do |v|
    options.quiet = v
  end
  opts.on("-a", "--altcommand c", String, "command to run when the results of glob changes") do |v|
    options.altcommand = v
  end
end.parse!

MYTEMP = ENV['TEMP'] || '/tmp'

command = ARGV.shift
LOCKFILE = File.join(MYTEMP, 'rstakeout.lock')
if options.synchronous
  lock_obj = File.new(LOCKFILE, 'w')
end

def with_exclusive_lock_if_synchronous(run_synced, lockfile, &block)
  lockfile.flock(File::LOCK_EX) if run_synced
  block.call
  lockfile.flock(File::LOCK_UN) if run_synced
end

class Executor
  attr_reader :options, :lock_obj, :command, :files
  
  def initialize opt, lockobj, cmd
    @options = opt
    @lock_obj = lockobj
    @command = cmd
    @files = build_mtimes_hash(ARGV)
  end

  def execmd cmd
    with_exclusive_lock_if_synchronous(@options.synchronous, @lock_obj) do
	  results = base_shell(cmd)
      if results.exitstatus == 0
        Notifier.notify cmd, results.stdout.join("")
      else
        io = results.stderr.empty? ? results.stdout : results.stderr
        Notifier.notify "FAILED: #{cmd}", io.join("")
      end
    end
  end

  def exec
    if options.verbose
      p options
      p "Watching #{@files.keys.join(', ')}\n\nFiles: #{@files.keys.length}"
    end
    loop do
      runcmd = false
      runalt = false
      
	  fds = FileList.send(:[], ARGV)
	  fds.each do |fd|
        if @files.has_key? fd
          runcmd = true if (File.mtime(fd) > @files[fd])     
        else
          @files[fd] = File.mtime(fd)
          runalt = true
        end
      end
      runalt = true unless fds.size.eql? @files.size
      
      execmd @options.altcommand if runalt
      execmd @command if runcmd
          
      sleep @options.sleep_time
    end
  end
  
end

Executor.new(options, lock_obj, command).exec


